// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/manhrev/runtracking/backend/event/pkg/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/manhrev/runtracking/backend/event/pkg/ent/event"
	"github.com/manhrev/runtracking/backend/event/pkg/ent/eventgroupz"
	"github.com/manhrev/runtracking/backend/event/pkg/ent/groupzprogress"
	"github.com/manhrev/runtracking/backend/event/pkg/ent/memberprogress"
	"github.com/manhrev/runtracking/backend/event/pkg/ent/participate"
	"github.com/manhrev/runtracking/backend/event/pkg/ent/subevent"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// EventGroupz is the client for interacting with the EventGroupz builders.
	EventGroupz *EventGroupzClient
	// GroupzProgress is the client for interacting with the GroupzProgress builders.
	GroupzProgress *GroupzProgressClient
	// MemberProgress is the client for interacting with the MemberProgress builders.
	MemberProgress *MemberProgressClient
	// Participate is the client for interacting with the Participate builders.
	Participate *ParticipateClient
	// SubEvent is the client for interacting with the SubEvent builders.
	SubEvent *SubEventClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Event = NewEventClient(c.config)
	c.EventGroupz = NewEventGroupzClient(c.config)
	c.GroupzProgress = NewGroupzProgressClient(c.config)
	c.MemberProgress = NewMemberProgressClient(c.config)
	c.Participate = NewParticipateClient(c.config)
	c.SubEvent = NewSubEventClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		Event:          NewEventClient(cfg),
		EventGroupz:    NewEventGroupzClient(cfg),
		GroupzProgress: NewGroupzProgressClient(cfg),
		MemberProgress: NewMemberProgressClient(cfg),
		Participate:    NewParticipateClient(cfg),
		SubEvent:       NewSubEventClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		Event:          NewEventClient(cfg),
		EventGroupz:    NewEventGroupzClient(cfg),
		GroupzProgress: NewGroupzProgressClient(cfg),
		MemberProgress: NewMemberProgressClient(cfg),
		Participate:    NewParticipateClient(cfg),
		SubEvent:       NewSubEventClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Event.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Event, c.EventGroupz, c.GroupzProgress, c.MemberProgress, c.Participate,
		c.SubEvent,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Event, c.EventGroupz, c.GroupzProgress, c.MemberProgress, c.Participate,
		c.SubEvent,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *EventGroupzMutation:
		return c.EventGroupz.mutate(ctx, m)
	case *GroupzProgressMutation:
		return c.GroupzProgress.mutate(ctx, m)
	case *MemberProgressMutation:
		return c.MemberProgress.mutate(ctx, m)
	case *ParticipateMutation:
		return c.Participate.mutate(ctx, m)
	case *SubEventMutation:
		return c.SubEvent.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id int64) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id int64) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id int64) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id int64) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubevents queries the subevents edge of a Event.
func (c *EventClient) QuerySubevents(e *Event) *SubEventQuery {
	query := (&SubEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(subevent.Table, subevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.SubeventsTable, event.SubeventsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a Event.
func (c *EventClient) QueryGroups(e *Event) *EventGroupzQuery {
	query := (&EventGroupzClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(eventgroupz.Table, eventgroupz.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, event.GroupsTable, event.GroupsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipates queries the participates edge of a Event.
func (c *EventClient) QueryParticipates(e *Event) *ParticipateQuery {
	query := (&ParticipateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(participate.Table, participate.EventColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, event.ParticipatesTable, event.ParticipatesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Event mutation op: %q", m.Op())
	}
}

// EventGroupzClient is a client for the EventGroupz schema.
type EventGroupzClient struct {
	config
}

// NewEventGroupzClient returns a client for the EventGroupz from the given config.
func NewEventGroupzClient(c config) *EventGroupzClient {
	return &EventGroupzClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventgroupz.Hooks(f(g(h())))`.
func (c *EventGroupzClient) Use(hooks ...Hook) {
	c.hooks.EventGroupz = append(c.hooks.EventGroupz, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventgroupz.Intercept(f(g(h())))`.
func (c *EventGroupzClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventGroupz = append(c.inters.EventGroupz, interceptors...)
}

// Create returns a builder for creating a EventGroupz entity.
func (c *EventGroupzClient) Create() *EventGroupzCreate {
	mutation := newEventGroupzMutation(c.config, OpCreate)
	return &EventGroupzCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventGroupz entities.
func (c *EventGroupzClient) CreateBulk(builders ...*EventGroupzCreate) *EventGroupzCreateBulk {
	return &EventGroupzCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventGroupz.
func (c *EventGroupzClient) Update() *EventGroupzUpdate {
	mutation := newEventGroupzMutation(c.config, OpUpdate)
	return &EventGroupzUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventGroupzClient) UpdateOne(eg *EventGroupz) *EventGroupzUpdateOne {
	mutation := newEventGroupzMutation(c.config, OpUpdateOne, withEventGroupz(eg))
	return &EventGroupzUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventGroupzClient) UpdateOneID(id int64) *EventGroupzUpdateOne {
	mutation := newEventGroupzMutation(c.config, OpUpdateOne, withEventGroupzID(id))
	return &EventGroupzUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventGroupz.
func (c *EventGroupzClient) Delete() *EventGroupzDelete {
	mutation := newEventGroupzMutation(c.config, OpDelete)
	return &EventGroupzDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventGroupzClient) DeleteOne(eg *EventGroupz) *EventGroupzDeleteOne {
	return c.DeleteOneID(eg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventGroupzClient) DeleteOneID(id int64) *EventGroupzDeleteOne {
	builder := c.Delete().Where(eventgroupz.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventGroupzDeleteOne{builder}
}

// Query returns a query builder for EventGroupz.
func (c *EventGroupzClient) Query() *EventGroupzQuery {
	return &EventGroupzQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventGroupz},
		inters: c.Interceptors(),
	}
}

// Get returns a EventGroupz entity by its id.
func (c *EventGroupzClient) Get(ctx context.Context, id int64) (*EventGroupz, error) {
	return c.Query().Where(eventgroupz.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventGroupzClient) GetX(ctx context.Context, id int64) *EventGroupz {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a EventGroupz.
func (c *EventGroupzClient) QueryEvent(eg *EventGroupz) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventgroupz.Table, eventgroupz.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, eventgroupz.EventTable, eventgroupz.EventPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipates queries the participates edge of a EventGroupz.
func (c *EventGroupzClient) QueryParticipates(eg *EventGroupz) *ParticipateQuery {
	query := (&ParticipateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventgroupz.Table, eventgroupz.FieldID, id),
			sqlgraph.To(participate.Table, participate.EventGroupColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, eventgroupz.ParticipatesTable, eventgroupz.ParticipatesColumn),
		)
		fromV = sqlgraph.Neighbors(eg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventGroupzClient) Hooks() []Hook {
	return c.hooks.EventGroupz
}

// Interceptors returns the client interceptors.
func (c *EventGroupzClient) Interceptors() []Interceptor {
	return c.inters.EventGroupz
}

func (c *EventGroupzClient) mutate(ctx context.Context, m *EventGroupzMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventGroupzCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventGroupzUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventGroupzUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventGroupzDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EventGroupz mutation op: %q", m.Op())
	}
}

// GroupzProgressClient is a client for the GroupzProgress schema.
type GroupzProgressClient struct {
	config
}

// NewGroupzProgressClient returns a client for the GroupzProgress from the given config.
func NewGroupzProgressClient(c config) *GroupzProgressClient {
	return &GroupzProgressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupzprogress.Hooks(f(g(h())))`.
func (c *GroupzProgressClient) Use(hooks ...Hook) {
	c.hooks.GroupzProgress = append(c.hooks.GroupzProgress, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupzprogress.Intercept(f(g(h())))`.
func (c *GroupzProgressClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupzProgress = append(c.inters.GroupzProgress, interceptors...)
}

// Create returns a builder for creating a GroupzProgress entity.
func (c *GroupzProgressClient) Create() *GroupzProgressCreate {
	mutation := newGroupzProgressMutation(c.config, OpCreate)
	return &GroupzProgressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupzProgress entities.
func (c *GroupzProgressClient) CreateBulk(builders ...*GroupzProgressCreate) *GroupzProgressCreateBulk {
	return &GroupzProgressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupzProgress.
func (c *GroupzProgressClient) Update() *GroupzProgressUpdate {
	mutation := newGroupzProgressMutation(c.config, OpUpdate)
	return &GroupzProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupzProgressClient) UpdateOne(gp *GroupzProgress) *GroupzProgressUpdateOne {
	mutation := newGroupzProgressMutation(c.config, OpUpdateOne, withGroupzProgress(gp))
	return &GroupzProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupzProgressClient) UpdateOneID(id int64) *GroupzProgressUpdateOne {
	mutation := newGroupzProgressMutation(c.config, OpUpdateOne, withGroupzProgressID(id))
	return &GroupzProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupzProgress.
func (c *GroupzProgressClient) Delete() *GroupzProgressDelete {
	mutation := newGroupzProgressMutation(c.config, OpDelete)
	return &GroupzProgressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupzProgressClient) DeleteOne(gp *GroupzProgress) *GroupzProgressDeleteOne {
	return c.DeleteOneID(gp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupzProgressClient) DeleteOneID(id int64) *GroupzProgressDeleteOne {
	builder := c.Delete().Where(groupzprogress.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupzProgressDeleteOne{builder}
}

// Query returns a query builder for GroupzProgress.
func (c *GroupzProgressClient) Query() *GroupzProgressQuery {
	return &GroupzProgressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupzProgress},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupzProgress entity by its id.
func (c *GroupzProgressClient) Get(ctx context.Context, id int64) (*GroupzProgress, error) {
	return c.Query().Where(groupzprogress.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupzProgressClient) GetX(ctx context.Context, id int64) *GroupzProgress {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubEvent queries the sub_event edge of a GroupzProgress.
func (c *GroupzProgressClient) QuerySubEvent(gp *GroupzProgress) *SubEventQuery {
	query := (&SubEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupzprogress.Table, groupzprogress.FieldID, id),
			sqlgraph.To(subevent.Table, subevent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, groupzprogress.SubEventTable, groupzprogress.SubEventColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMember queries the member edge of a GroupzProgress.
func (c *GroupzProgressClient) QueryMember(gp *GroupzProgress) *MemberProgressQuery {
	query := (&MemberProgressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupzprogress.Table, groupzprogress.FieldID, id),
			sqlgraph.To(memberprogress.Table, memberprogress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, groupzprogress.MemberTable, groupzprogress.MemberColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupzProgressClient) Hooks() []Hook {
	return c.hooks.GroupzProgress
}

// Interceptors returns the client interceptors.
func (c *GroupzProgressClient) Interceptors() []Interceptor {
	return c.inters.GroupzProgress
}

func (c *GroupzProgressClient) mutate(ctx context.Context, m *GroupzProgressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupzProgressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupzProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupzProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupzProgressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GroupzProgress mutation op: %q", m.Op())
	}
}

// MemberProgressClient is a client for the MemberProgress schema.
type MemberProgressClient struct {
	config
}

// NewMemberProgressClient returns a client for the MemberProgress from the given config.
func NewMemberProgressClient(c config) *MemberProgressClient {
	return &MemberProgressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberprogress.Hooks(f(g(h())))`.
func (c *MemberProgressClient) Use(hooks ...Hook) {
	c.hooks.MemberProgress = append(c.hooks.MemberProgress, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberprogress.Intercept(f(g(h())))`.
func (c *MemberProgressClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberProgress = append(c.inters.MemberProgress, interceptors...)
}

// Create returns a builder for creating a MemberProgress entity.
func (c *MemberProgressClient) Create() *MemberProgressCreate {
	mutation := newMemberProgressMutation(c.config, OpCreate)
	return &MemberProgressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberProgress entities.
func (c *MemberProgressClient) CreateBulk(builders ...*MemberProgressCreate) *MemberProgressCreateBulk {
	return &MemberProgressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberProgress.
func (c *MemberProgressClient) Update() *MemberProgressUpdate {
	mutation := newMemberProgressMutation(c.config, OpUpdate)
	return &MemberProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberProgressClient) UpdateOne(mp *MemberProgress) *MemberProgressUpdateOne {
	mutation := newMemberProgressMutation(c.config, OpUpdateOne, withMemberProgress(mp))
	return &MemberProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberProgressClient) UpdateOneID(id int64) *MemberProgressUpdateOne {
	mutation := newMemberProgressMutation(c.config, OpUpdateOne, withMemberProgressID(id))
	return &MemberProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberProgress.
func (c *MemberProgressClient) Delete() *MemberProgressDelete {
	mutation := newMemberProgressMutation(c.config, OpDelete)
	return &MemberProgressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberProgressClient) DeleteOne(mp *MemberProgress) *MemberProgressDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberProgressClient) DeleteOneID(id int64) *MemberProgressDeleteOne {
	builder := c.Delete().Where(memberprogress.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberProgressDeleteOne{builder}
}

// Query returns a query builder for MemberProgress.
func (c *MemberProgressClient) Query() *MemberProgressQuery {
	return &MemberProgressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberProgress},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberProgress entity by its id.
func (c *MemberProgressClient) Get(ctx context.Context, id int64) (*MemberProgress, error) {
	return c.Query().Where(memberprogress.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberProgressClient) GetX(ctx context.Context, id int64) *MemberProgress {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a MemberProgress.
func (c *MemberProgressClient) QueryGroup(mp *MemberProgress) *GroupzProgressQuery {
	query := (&GroupzProgressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memberprogress.Table, memberprogress.FieldID, id),
			sqlgraph.To(groupzprogress.Table, groupzprogress.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memberprogress.GroupTable, memberprogress.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemberProgressClient) Hooks() []Hook {
	return c.hooks.MemberProgress
}

// Interceptors returns the client interceptors.
func (c *MemberProgressClient) Interceptors() []Interceptor {
	return c.inters.MemberProgress
}

func (c *MemberProgressClient) mutate(ctx context.Context, m *MemberProgressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberProgressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberProgressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemberProgress mutation op: %q", m.Op())
	}
}

// ParticipateClient is a client for the Participate schema.
type ParticipateClient struct {
	config
}

// NewParticipateClient returns a client for the Participate from the given config.
func NewParticipateClient(c config) *ParticipateClient {
	return &ParticipateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `participate.Hooks(f(g(h())))`.
func (c *ParticipateClient) Use(hooks ...Hook) {
	c.hooks.Participate = append(c.hooks.Participate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `participate.Intercept(f(g(h())))`.
func (c *ParticipateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Participate = append(c.inters.Participate, interceptors...)
}

// Create returns a builder for creating a Participate entity.
func (c *ParticipateClient) Create() *ParticipateCreate {
	mutation := newParticipateMutation(c.config, OpCreate)
	return &ParticipateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Participate entities.
func (c *ParticipateClient) CreateBulk(builders ...*ParticipateCreate) *ParticipateCreateBulk {
	return &ParticipateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Participate.
func (c *ParticipateClient) Update() *ParticipateUpdate {
	mutation := newParticipateMutation(c.config, OpUpdate)
	return &ParticipateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ParticipateClient) UpdateOne(pa *Participate) *ParticipateUpdateOne {
	mutation := newParticipateMutation(c.config, OpUpdateOne)
	mutation.event = &pa.EventID
	mutation.event_group = &pa.EventGroupID
	return &ParticipateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Participate.
func (c *ParticipateClient) Delete() *ParticipateDelete {
	mutation := newParticipateMutation(c.config, OpDelete)
	return &ParticipateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for Participate.
func (c *ParticipateClient) Query() *ParticipateQuery {
	return &ParticipateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeParticipate},
		inters: c.Interceptors(),
	}
}

// QueryEvent queries the event edge of a Participate.
func (c *ParticipateClient) QueryEvent(pa *Participate) *EventQuery {
	return c.Query().
		Where(participate.EventID(pa.EventID), participate.EventGroupID(pa.EventGroupID)).
		QueryEvent()
}

// QueryEventGroup queries the event_group edge of a Participate.
func (c *ParticipateClient) QueryEventGroup(pa *Participate) *EventGroupzQuery {
	return c.Query().
		Where(participate.EventID(pa.EventID), participate.EventGroupID(pa.EventGroupID)).
		QueryEventGroup()
}

// Hooks returns the client hooks.
func (c *ParticipateClient) Hooks() []Hook {
	return c.hooks.Participate
}

// Interceptors returns the client interceptors.
func (c *ParticipateClient) Interceptors() []Interceptor {
	return c.inters.Participate
}

func (c *ParticipateClient) mutate(ctx context.Context, m *ParticipateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ParticipateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ParticipateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ParticipateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ParticipateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Participate mutation op: %q", m.Op())
	}
}

// SubEventClient is a client for the SubEvent schema.
type SubEventClient struct {
	config
}

// NewSubEventClient returns a client for the SubEvent from the given config.
func NewSubEventClient(c config) *SubEventClient {
	return &SubEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subevent.Hooks(f(g(h())))`.
func (c *SubEventClient) Use(hooks ...Hook) {
	c.hooks.SubEvent = append(c.hooks.SubEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subevent.Intercept(f(g(h())))`.
func (c *SubEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubEvent = append(c.inters.SubEvent, interceptors...)
}

// Create returns a builder for creating a SubEvent entity.
func (c *SubEventClient) Create() *SubEventCreate {
	mutation := newSubEventMutation(c.config, OpCreate)
	return &SubEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubEvent entities.
func (c *SubEventClient) CreateBulk(builders ...*SubEventCreate) *SubEventCreateBulk {
	return &SubEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubEvent.
func (c *SubEventClient) Update() *SubEventUpdate {
	mutation := newSubEventMutation(c.config, OpUpdate)
	return &SubEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubEventClient) UpdateOne(se *SubEvent) *SubEventUpdateOne {
	mutation := newSubEventMutation(c.config, OpUpdateOne, withSubEvent(se))
	return &SubEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubEventClient) UpdateOneID(id int64) *SubEventUpdateOne {
	mutation := newSubEventMutation(c.config, OpUpdateOne, withSubEventID(id))
	return &SubEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubEvent.
func (c *SubEventClient) Delete() *SubEventDelete {
	mutation := newSubEventMutation(c.config, OpDelete)
	return &SubEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubEventClient) DeleteOne(se *SubEvent) *SubEventDeleteOne {
	return c.DeleteOneID(se.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubEventClient) DeleteOneID(id int64) *SubEventDeleteOne {
	builder := c.Delete().Where(subevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubEventDeleteOne{builder}
}

// Query returns a query builder for SubEvent.
func (c *SubEventClient) Query() *SubEventQuery {
	return &SubEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a SubEvent entity by its id.
func (c *SubEventClient) Get(ctx context.Context, id int64) (*SubEvent, error) {
	return c.Query().Where(subevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubEventClient) GetX(ctx context.Context, id int64) *SubEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a SubEvent.
func (c *SubEventClient) QueryEvent(se *SubEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subevent.Table, subevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subevent.EventTable, subevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a SubEvent.
func (c *SubEventClient) QueryGroup(se *SubEvent) *GroupzProgressQuery {
	query := (&GroupzProgressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subevent.Table, subevent.FieldID, id),
			sqlgraph.To(groupzprogress.Table, groupzprogress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subevent.GroupTable, subevent.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubEventClient) Hooks() []Hook {
	return c.hooks.SubEvent
}

// Interceptors returns the client interceptors.
func (c *SubEventClient) Interceptors() []Interceptor {
	return c.inters.SubEvent
}

func (c *SubEventClient) mutate(ctx context.Context, m *SubEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SubEvent mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Event, EventGroupz, GroupzProgress, MemberProgress, Participate,
		SubEvent []ent.Hook
	}
	inters struct {
		Event, EventGroupz, GroupzProgress, MemberProgress, Participate,
		SubEvent []ent.Interceptor
	}
)
